add_faces.py
---------------------
import cv2
import pickle
import numpy as np
import os
from skimage.metrics import structural_similarity as ssim

# Open the camera
video = cv2.VideoCapture(0)

if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

# Load Haarcascade for face detection
facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Create data directory if not exists
if not os.path.exists('data'):
    os.makedirs('data')

faces_data = []
i = 0

name = input("Enter Your Name: ")

faces_file = 'data/faces_data.pkl'
names_file = 'data/names.pkl'

# Load existing face data if available
if os.path.exists(faces_file):
    with open(faces_file, 'rb') as f:
        stored_faces = pickle.load(f)
        stored_faces = stored_faces.reshape(-1, 50, 50, 3)  # Reshape properly
else:
    stored_faces = np.empty((0, 50, 50, 3), dtype=np.uint8)  # Empty dataset

def mse(image1, image2):
    """Mean Squared Error (MSE) between two images"""
    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)
    err /= float(image1.shape[0] * image1.shape[1])
    return err

def is_duplicate(face):
    """Check if the captured face already exists in stored_faces."""
    if stored_faces.shape[0] == 0:
        return False  # No stored faces yet

    face_gray = cv2.cvtColor(face, cv2.COLOR_BGR2GRAY)  # Convert new face to grayscale

    for stored_face in stored_faces:
        stored_face_gray = cv2.cvtColor(stored_face, cv2.COLOR_BGR2GRAY)  # Convert stored face to grayscale
        
        # Ensure both images are the same size
        if face_gray.shape != stored_face_gray.shape:
            continue

        # Calculate MSE and SSIM between new face and stored faces
        mse_score = mse(face_gray, stored_face_gray)
        ssim_score = ssim(face_gray, stored_face_gray)

        # If the similarity is high (low MSE, high SSIM), it's a duplicate
        if mse_score < 200 and ssim_score > 0.8:
            return True

    return False

while True:
    ret, frame = video.read()
    
    if not ret:
        print("Error: Could not capture frame.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)
    duplicate_detected = False

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]

        if crop_img.size == 0:
            print("Error: Empty face image.")
            continue

        resized_img = cv2.resize(crop_img, (50, 50))

        if is_duplicate(resized_img):
            duplicate_detected = True
            cv2.putText(frame, "Duplicate Face Detected!", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 
                        0.6, (0, 0, 255), 2)
        elif len(faces_data) < 100 and i % 10 == 0:
            faces_data.append(resized_img)

        i += 1
        cv2.putText(frame, str(len(faces_data)), (50, 50), cv2.FONT_HERSHEY_COMPLEX, 1, (50, 50, 255), 1)
        cv2.rectangle(frame, (x, y), (x + w, y + h), (50, 50, 255), 1)

    cv2.imshow("Frame", frame)
    k = cv2.waitKey(1)

    if k == ord('q') or len(faces_data) == 100:
        break

video.release()
cv2.destroyAllWindows()

# Convert to NumPy array and reshape dynamically
faces_data = np.asarray(faces_data)
faces_data = faces_data.reshape(len(faces_data), 50, 50, 3)  # Store in proper shape

# Save names
if not os.path.exists(names_file):
    names = [name] * len(faces_data)
    with open(names_file, 'wb') as f:
        pickle.dump(names, f)
else:
    with open(names_file, 'rb') as f:
        names = pickle.load(f)
    names.extend([name] * len(faces_data))
    with open(names_file, 'wb') as f:
        pickle.dump(names, f)

# Save face data only if not duplicate
if not os.path.exists(faces_file):
    with open(faces_file, 'wb') as f:
        pickle.dump(faces_data, f)
else:
    with open(faces_file, 'rb') as f:
        stored_faces = pickle.load(f)
        stored_faces = stored_faces.reshape(-1, 50, 50, 3)  # Ensure correct shape

    stored_faces = np.vstack((stored_faces, faces_data))  # Use `vstack` for proper concatenation
    with open(faces_file, 'wb') as f:
        pickle.dump(stored_faces, f)



------------------------------------------------------------
test.py
-------
from sklearn.neighbors import KNeighborsClassifier
import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
from win32com.client import Dispatch

def speak(text):
    speaker = Dispatch("SAPI.SpVoice")
    speaker.Speak(text)

# Load the face recognition model and labels
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print("Error loading face data:", e)
    exit()

# Ensure FACES is a NumPy array and reshape to 2D
FACES = np.array(FACES).reshape(FACES.shape[0], -1)
print('Shape of Faces matrix --> ', FACES.shape)

# Train KNN model
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

# Updated header with three columns: NAME, DATE, TIME
COL_NAMES = ['NAME', 'DATE', 'TIME']

if not os.path.exists("Attendance"):
    os.makedirs("Attendance")

# Set to keep track of attendance already marked for this session/day
attended = set()

while True:
    ret, frame = video.read()
    if not ret:
        print("Error: Frame not captured.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        if w == 0 or h == 0:
            continue  # Skip invalid detections
        
        crop_img = frame[y:y+h, x:x+w]
        if crop_img.size == 0:
            print("Error: Cropped image is empty.")
            continue  # Skip this iteration
        
        # Resize the cropped face and prepare for prediction
        resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)
        
        try:
            output = knn.predict(resized_img)
            recognized_name = output[0]
            print("Recognized:", recognized_name)
        except Exception as e:
            print("Prediction Error:", e)
            continue

        # Draw bounding boxes and label the face
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 0, 255), 1)
        cv2.rectangle(frame, (x, y), (x+w, y+h), (50, 50, 255), 2)
        cv2.rectangle(frame, (x, y-40), (x+w, y), (50, 50, 255), -1)
        cv2.putText(frame, str(recognized_name), (x, y-15), cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 1)

        # Automatically mark attendance if not already marked
        if recognized_name not in attended:
            ts = time.time()
            date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")
            timestamp = datetime.fromtimestamp(ts).strftime("%H:%M:%S")
            attendance_file = f"Attendance/Attendance_{date}.csv"
            file_exists = os.path.isfile(attendance_file)
            
            # If the file exists, check if it's in the old format and update it if necessary
            if file_exists:
                with open(attendance_file, "r", newline="") as csvfile:
                    reader = csv.reader(csvfile)
                    header = next(reader)
                if header == ['NAME', 'TIME']:  # old format detected
                    # Read all existing rows
                    with open(attendance_file, "r", newline="") as csvfile:
                        rows = list(csv.reader(csvfile))
                    # Create new rows with updated header
                    new_rows = [COL_NAMES]
                    # Insert the current date for existing records
                    for row in rows[1:]:
                        if len(row) == 2:
                            new_rows.append([row[0], date, row[1]])
                        else:
                            new_rows.append(row)
                    # Write the updated rows back to the file
                    with open(attendance_file, "w", newline="") as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerows(new_rows)
            
            # Append the new attendance record
            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not file_exists:
                    writer.writerow(COL_NAMES)
                writer.writerow([str(recognized_name), date, timestamp])
            
            attended.add(recognized_name)
            speak("Attendance Taken.")

    cv2.imshow("Frame", frame)

    # Press 'q' to quit the program
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

video.release()
cv2.destroyAllWindows()
-----------------------------------------------------------------------------------
app.py
-------
import pandas as pd
import os
import time
import streamlit as st
from datetime import datetime
from streamlit_autorefresh import st_autorefresh

# Ensure Streamlit maintains execution context
st.experimental_set_query_params(refresh="true")

# Get current date and timestamp
ts = time.time()
date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")

# Auto-refresh every 2 seconds
count = st_autorefresh(interval=2000, key="fizzbuzzcounter")

# Display FizzBuzz Logic
if count % 3 == 0 and count % 5 == 0:
    st.write("FizzBuzz")
elif count % 3 == 0:
    st.write("Fizz")
elif count % 5 == 0:
    st.write("Buzz")
else:
    st.write(f"Count: {count}")

# Attendance CSV File Path
csv_file_path = f"Attendance/Attendance_{date}.csv"

# Display header with current date
st.header(f"Attendance Record for {date}")

if os.path.exists(csv_file_path):
    # Check CSV header format
    with open(csv_file_path, 'r') as f:
        header_line = f.readline().strip()
        header_fields = header_line.split(',')
    
    expected_columns = ['NAME', 'DATE', 'TIME']
    
    # If file is in old format with 2 columns, update it automatically
    if len(header_fields) == 2 and header_fields == ['NAME', 'TIME']:
        try:
            df_old = pd.read_csv(csv_file_path)
            # Add DATE column with the current date for each row
            df_old['DATE'] = date
            # Reorder columns to match the expected format
            df_new = df_old[['NAME', 'DATE', 'TIME']]
            df_new.to_csv(csv_file_path, index=False)
            st.info("CSV file updated to new format (added DATE column).")
        except Exception as e:
            st.error(f"Error updating CSV file: {e}")
    elif len(header_fields) != len(expected_columns):
        st.error(
            f"CSV file format error: Expected {len(expected_columns)} columns {expected_columns} "
            f"but found {len(header_fields)} columns: {header_fields}. "
            "Please update or delete the file to use the new format."
        )

    # Try reading the CSV file with retries
    retry = 3  # Number of retry attempts
    for attempt in range(retry):
        try:
            df = pd.read_csv(csv_file_path)
            # Search Filter Input
            search_query = st.text_input("Search Attendance Record:", "")
            # Filter DataFrame based on search query
            if search_query:
                filtered_df = df[df.apply(lambda row: row.astype(str).str.contains(search_query, case=False, na=False).any(), axis=1)]
            else:
                filtered_df = df
            # Display DataFrame with highlighted max values
            st.dataframe(filtered_df.style.highlight_max(axis=0))
            break  # Successfully read and displayed the file
        except Exception as e:
            if attempt < retry - 1:
                time.sleep(1)  # Wait and retry
            else:
                st.error(f"Error reading the CSV file: {e}")
else:
    st.warning(f"No attendance record found for {date}.")

------------------------------test.py------------------------dummy-----------------
from sklearn.neighbors import KNeighborsClassifier
import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3

# Initialize pyttsx3 engine for text-to-speech
engine = pyttsx3.init()

def speak(text):
    engine.say(text)
    engine.runAndWait()

# Load the face recognition model and labels
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print("Error loading face data:", e)
    exit()

# Ensure FACES is a NumPy array and reshape to 2D
FACES = np.array(FACES).reshape(FACES.shape[0], -1)
print('Shape of Faces matrix --> ', FACES.shape)

# Train KNN model
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

# Updated header with three columns: NAME, DATE, TIME
COL_NAMES = ['NAME', 'DATE', 'TIME']

if not os.path.exists("Attendance"):
    os.makedirs("Attendance")

# Set to keep track of attendance already marked for this session/day
attended = set()

while True:
    ret, frame = video.read()
    if not ret:
        print("Error: Frame not captured.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        if w == 0 or h == 0:
            continue  # Skip invalid detections
        
        crop_img = frame[y:y+h, x:x+w]
        if crop_img.size == 0:
            print("Error: Cropped image is empty.")
            continue  # Skip this iteration
        
        # Resize the cropped face and prepare for prediction
        resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)
        
        try:
            output = knn.predict(resized_img)
            recognized_name = output[0]
            print("Recognized:", recognized_name)
        except Exception as e:
            print("Prediction Error:", e)
            continue

        # Draw bounding boxes and label the face
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 0, 255), 1)
        cv2.rectangle(frame, (x, y), (x+w, y+h), (50, 50, 255), 2)
        cv2.rectangle(frame, (x, y-40), (x+w, y), (50, 50, 255), -1)
        cv2.putText(frame, str(recognized_name), (x, y-15), cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 1)

        # Automatically mark attendance if not already marked
        if recognized_name not in attended:
            ts = time.time()
            date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")
            timestamp = datetime.fromtimestamp(ts).strftime("%H:%M:%S")
            attendance_file = f"Attendance/Attendance_{date}.csv"
            file_exists = os.path.isfile(attendance_file)
            
            # If the file exists, check if it's in the old format and update it if necessary
            if file_exists:
                with open(attendance_file, "r", newline="") as csvfile:
                    reader = csv.reader(csvfile)
                    header = next(reader)
                if header == ['NAME', 'TIME']:  # old format detected
                    # Read all existing rows
                    with open(attendance_file, "r", newline="") as csvfile:
                        rows = list(csv.reader(csvfile))
                    # Create new rows with updated header
                    new_rows = [COL_NAMES]
                    # Insert the current date for existing records
                    for row in rows[1:]:
                        if len(row) == 2:
                            new_rows.append([row[0], date, row[1]])
                        else:
                            new_rows.append(row)
                    # Write the updated rows back to the file
                    with open(attendance_file, "w", newline="") as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerows(new_rows)
            
            # Append the new attendance record
            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not file_exists:
                    writer.writerow(COL_NAMES)
                writer.writerow([str(recognized_name), date, timestamp])
            
            attended.add(recognized_name)
            speak("Attendance Taken.")

    cv2.imshow("Frame", frame)

    # Press 'q' to quit the program
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

video.release()
cv2.destroyAllWindows()
-----------------------------------------------------------------------------------
buzzer added
---------
from sklearn.neighbors import KNeighborsClassifier
import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3
import RPi.GPIO as GPIO

# Initialize GPIO for buzzer
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17  # Change as needed for your wiring
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)

# Initialize pyttsx3 engine for text-to-speech
engine = pyttsx3.init()

def speak(text):
    engine.say(text)
    engine.runAndWait()

# Load the face recognition model and labels
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print("Error loading face data:", e)
    exit()

# Ensure FACES is a NumPy array and reshape to 2D
FACES = np.array(FACES).reshape(FACES.shape[0], -1)
print('Shape of Faces matrix --> ', FACES.shape)

# Train KNN model
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

# Updated header with three columns: NAME, DATE, TIME
COL_NAMES = ['NAME', 'DATE', 'TIME']

if not os.path.exists("Attendance"):
    os.makedirs("Attendance")

# Set to keep track of attendance already marked for this session/day
attended = set()

while True:
    ret, frame = video.read()
    if not ret:
        print("Error: Frame not captured.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        if w == 0 or h == 0:
            continue  # Skip invalid detections

        crop_img = frame[y:y+h, x:x+w]
        if crop_img.size == 0:
            print("Error: Cropped image is empty.")
            continue  # Skip this iteration

        # Resize the cropped face and prepare for prediction
        resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)

        try:
            output = knn.predict(resized_img)
            recognized_name = output[0]
            print("Recognized:", recognized_name)
        except Exception as e:
            print("Prediction Error:", e)
            continue

        # Draw bounding boxes and label the face
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 0, 255), 1)
        cv2.rectangle(frame, (x, y), (x+w, y+h), (50, 50, 255), 2)
        cv2.rectangle(frame, (x, y-40), (x+w, y), (50, 50, 255), -1)
        cv2.putText(frame, str(recognized_name), (x, y-15),
                    cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 1)

        # Automatically mark attendance if not already marked
        if recognized_name not in attended:
            ts = time.time()
            date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")
            timestamp = datetime.fromtimestamp(ts).strftime("%H:%M:%S")
            attendance_file = f"Attendance/Attendance_{date}.csv"
            file_exists = os.path.isfile(attendance_file)

            # If the file exists, check if it's in the old format and update it if necessary
            if file_exists:
                with open(attendance_file, "r", newline="") as csvfile:
                    reader = csv.reader(csvfile)
                    header = next(reader)
                if header == ['NAME', 'TIME']:  # old format detected
                    # Read all existing rows
                    with open(attendance_file, "r", newline="") as csvfile:
                        rows = list(csv.reader(csvfile))
                    # Create new rows with updated header
                    new_rows = [COL_NAMES]
                    # Insert the current date for existing records
                    for row in rows[1:]:
                        if len(row) == 2:
                            new_rows.append([row[0], date, row[1]])
                        else:
                            new_rows.append(row)
                    # Write the updated rows back to the file
                    with open(attendance_file, "w", newline="") as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerows(new_rows)

            # Append the new attendance record
            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not file_exists:
                    writer.writerow(COL_NAMES)
                writer.writerow([str(recognized_name), date, timestamp])

            attended.add(recognized_name)
            speak("Attendance Taken.")

            # Buzz the buzzer two times (each beep lasting 1 second)
            for _ in range(2):
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                time.sleep(1)
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                time.sleep(0.5)

    cv2.imshow("Frame", frame)

    # Press 'q' to quit the program
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

video.release()
cv2.destroyAllWindows()
GPIO.cleanup()
-----------------------------------------------------------------------add-api---------------------------
from sklearn.neighbors import KNeighborsClassifier
import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3
import RPi.GPIO as GPIO
import requests  # For sending data to an API

# Initialize GPIO for buzzer
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17  # Change as needed for your wiring
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)

# Initialize pyttsx3 engine for text-to-speech
engine = pyttsx3.init()

def speak(text):
    engine.say(text)
    engine.runAndWait()

def send_attendance_api(name, date, timestamp):
    # Replace the URL below with your actual API endpoint
    api_url = "http://your-api-url.com/attendance"  
    payload = {
        "name": name,
        "date": date,
        "time": timestamp
    }
    try:
        response = requests.post(api_url, json=payload)
        if response.status_code == 200:
            print("Attendance data successfully sent to API.")
        else:
            print("Failed to send attendance data. Status code:", response.status_code)
    except Exception as e:
        print("Error sending attendance data to API:", e)

# Load the face recognition model and labels
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print("Error loading face data:", e)
    exit()

# Ensure FACES is a NumPy array and reshape to 2D
FACES = np.array(FACES).reshape(FACES.shape[0], -1)
print('Shape of Faces matrix --> ', FACES.shape)

# Train KNN model
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

# Updated header with three columns: NAME, DATE, TIME
COL_NAMES = ['NAME', 'DATE', 'TIME']

if not os.path.exists("Attendance"):
    os.makedirs("Attendance")

# Set to keep track of attendance already marked for this session/day
attended = set()

while True:
    ret, frame = video.read()
    if not ret:
        print("Error: Frame not captured.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        if w == 0 or h == 0:
            continue  # Skip invalid detections

        crop_img = frame[y:y+h, x:x+w]
        if crop_img.size == 0:
            print("Error: Cropped image is empty.")
            continue

        # Resize the cropped face and prepare for prediction
        try:
            resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)
        except Exception as e:
            print("Error resizing image:", e)
            continue

        try:
            output = knn.predict(resized_img)
            recognized_name = output[0]
            print("Recognized:", recognized_name)
        except Exception as e:
            print("Prediction Error:", e)
            continue

        # Draw bounding boxes and label the face
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 0, 255), 1)
        cv2.rectangle(frame, (x, y), (x+w, y+h), (50, 50, 255), 2)
        cv2.rectangle(frame, (x, y-40), (x+w, y), (50, 50, 255), -1)
        cv2.putText(frame, str(recognized_name), (x, y-15),
                    cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 1)

        # Automatically mark attendance if not already marked
        if recognized_name not in attended:
            ts = time.time()
            date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")
            timestamp = datetime.fromtimestamp(ts).strftime("%H:%M:%S")
            attendance_file = f"Attendance/Attendance_{date}.csv"
            file_exists = os.path.isfile(attendance_file)

            # If the file exists, check if it's in the old format and update it if necessary
            if file_exists:
                with open(attendance_file, "r", newline="") as csvfile:
                    reader = csv.reader(csvfile)
                    header = next(reader)
                if header == ['NAME', 'TIME']:  # old format detected
                    with open(attendance_file, "r", newline="") as csvfile:
                        rows = list(csv.reader(csvfile))
                    new_rows = [COL_NAMES]
                    for row in rows[1:]:
                        if len(row) == 2:
                            new_rows.append([row[0], date, row[1]])
                        else:
                            new_rows.append(row)
                    with open(attendance_file, "w", newline="") as csvfile:
                        writer = csv.writer(csvfile)
                        writer.writerows(new_rows)

            # Append the new attendance record to CSV
            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not file_exists:
                    writer.writerow(COL_NAMES)
                writer.writerow([str(recognized_name), date, timestamp])

            attended.add(recognized_name)
            speak("Attendance Taken.")

            # Send attendance data to API
            send_attendance_api(str(recognized_name), date, timestamp)

            # Buzz the buzzer two times (each beep lasting 1 second)
            for _ in range(2):
                GPIO.output(BUZZER_PIN, GPIO.HIGH)
                time.sleep(1)
                GPIO.output(BUZZER_PIN, GPIO.LOW)
                time.sleep(0.5)

    cv2.imshow("Frame", frame)

    # Press 'q' to quit the program
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

video.release()
cv2.destroyAllWindows()
GPIO.cleanup()
---------------------------------------------------------------------------------------------------------------------------
#! /usr/bin/env python

import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3
import RPi.GPIO as GPIO
import requests  # For sending data to an API
import smbus2  # For I2C LCD display
import drivers  # LCD Driver Library
from time import sleep

# ✅ I2C LCD Configuration
I2C_ADDR = 0x27  # Change to 0x3F if needed
bus = smbus2.SMBus(1)
display = drivers.Lcd()  # Load LCD driver

# ✅ LCD Functions
def lcd_clear():
    """Clear LCD Display"""
    display.lcd_clear()

def lcd_print(message, line=1):
    """Print text on LCD"""
    message = message[:16]  # Ensure message is 16 characters max
    display.lcd_display_string(message, line)

# ✅ Initialize LCD
lcd_clear()
lcd_print("Attendance System", 1)
lcd_print("Initializing...", 2)
sleep(2)

# ✅ Initialize GPIO for buzzer
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17  
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)

# ✅ Initialize pyttsx3 for text-to-speech
engine = pyttsx3.init()

def speak(text):
    """Convert text to speech"""
    engine.say(text)
    engine.runAndWait()

def send_attendance_api(name, date, timestamp):
    """Send attendance data to API"""
    api_url = "http://localhost:5000/attendance"  
    payload = {"name": name, "date": date, "time": timestamp}
    try:
        response = requests.post(api_url, json=payload)
        if response.status_code == 200:
            print("Attendance data successfully sent to API.")
        else:
            print("Failed to send attendance data. Status code:", response.status_code)
    except Exception as e:
        print("Error sending attendance data to API:", e)

# ✅ Load Face Recognition Model
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print("Error loading face data:", e)
    exit()

FACES = np.array(FACES).reshape(FACES.shape[0], -1)
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

COL_NAMES = ['NAME', 'DATE', 'TIME']
if not os.path.exists("Attendance"):
    os.makedirs("Attendance")

attended = set()

# ✅ Face Recognition Loop
try:
    while True:
        ret, frame = video.read()
        if not ret:
            print("Error: Frame not captured.")
            break

        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        faces = facedetect.detectMultiScale(gray, 1.3, 5)

        if len(faces) == 0:
            # No face detected - show LCD demo text
            lcd_print("Greetings Human!", 1)
            lcd_print("Demo Pi Guy code", 2)
            sleep(2)
            lcd_print("I am a display!", 1)
            sleep(2)
            lcd_clear()
            sleep(2)
            continue

        for (x, y, w, h) in faces:
            if w == 0 or h == 0:
                continue  # Skip invalid detections

            crop_img = frame[y:y+h, x:x+w]

            if crop_img.size == 0:
                print("Error: Cropped image is empty.")
                continue

            try:
                resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)
            except Exception as e:
                print("Error resizing image:", e)
                continue

            try:
                output = knn.predict(resized_img)
                recognized_name = output[0]
                print("Recognized:", recognized_name)
            except Exception as e:
                print("Prediction Error:", e)
                continue

            if recognized_name not in attended:
                ts = time.time()
                date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")
                timestamp = datetime.fromtimestamp(ts).strftime("%H:%M:%S")

                attended.add(recognized_name)
                speak("Attendance Taken.")

                # ✅ Send Attendance Data to API
                send_attendance_api(str(recognized_name), date, timestamp)

                # ✅ Display Attendance Info on LCD
                lcd_clear()
                lcd_print(f"Name: {recognized_name[:16]}", 1)  # Trims long names
                lcd_print("Attendance Taken", 2)
                sleep(2)

                # ✅ Buzzer Alert (2 Beeps)
                for _ in range(2):
                    GPIO.output(BUZZER_PIN, GPIO.HIGH)
                    sleep(1)
                    GPIO.output(BUZZER_PIN, GPIO.LOW)
                    sleep(0.5)

        cv2.imshow("Frame", frame)

        # Press 'q' to quit
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

except KeyboardInterrupt:
    print("Cleaning up!")
    lcd_clear()

video.release()
cv2.destroyAllWindows()
GPIO.cleanup()
-------------------------------RFID-FACE-ADD----------------------------------------------------------
import cv2
import pickle
import numpy as np
import os
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
from skimage.metrics import structural_similarity as ssim

# Initialize RFID Reader
reader = SimpleMFRC522()

# Open the camera
video = cv2.VideoCapture(0)

if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

# Load Haarcascade for face detection
facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Create data directory if not exists
if not os.path.exists('data'):
    os.makedirs('data')

faces_data = []
rfid_data = []
i = 0

# Read RFID Card
print("Scan your RFID card...")
try:
    card_id, card_text = reader.read()
    print(f"RFID Card ID: {card_id}")
    name = input("Enter Your Name: ")
except Exception as e:
    print(f"RFID Error: {e}")
    exit()

# File paths
faces_file = 'data/faces_data.pkl'
names_file = 'data/names.pkl'
rfid_file = 'data/rfid_data.pkl'

# Load existing face data if available
if os.path.exists(faces_file):
    with open(faces_file, 'rb') as f:
        stored_faces = pickle.load(f)
        stored_faces = stored_faces.reshape(-1, 50, 50, 3)
else:
    stored_faces = np.empty((0, 50, 50, 3), dtype=np.uint8)

# Load existing RFID data
if os.path.exists(rfid_file):
    with open(rfid_file, 'rb') as f:
        stored_rfid = pickle.load(f)
else:
    stored_rfid = []

def mse(image1, image2):
    """Mean Squared Error (MSE) between two images"""
    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)
    err /= float(image1.shape[0] * image1.shape[1])
    return err

def is_duplicate(face):
    """Check if the captured face already exists in stored_faces."""
    if stored_faces.shape[0] == 0:
        return False  # No stored faces yet

    face_gray = cv2.cvtColor(face, cv2.COLOR_BGR2GRAY)

    for stored_face in stored_faces:
        stored_face_gray = cv2.cvtColor(stored_face, cv2.COLOR_BGR2GRAY)
        
        if face_gray.shape != stored_face_gray.shape:
            continue

        mse_score = mse(face_gray, stored_face_gray)
        ssim_score = ssim(face_gray, stored_face_gray)

        if mse_score < 200 and ssim_score > 0.8:
            return True

    return False

while True:
    ret, frame = video.read()
    
    if not ret:
        print("Error: Could not capture frame.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)
    duplicate_detected = False

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]

        if crop_img.size == 0:
            print("Error: Empty face image.")
            continue

        resized_img = cv2.resize(crop_img, (50, 50))

        if is_duplicate(resized_img):
            duplicate_detected = True
            cv2.putText(frame, "Duplicate Face Detected!", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 
                        0.6, (0, 0, 255), 2)
        elif len(faces_data) < 100 and i % 10 == 0:
            faces_data.append(resized_img)
            rfid_data.append(card_id)  # Store RFID along with face data

        i += 1
        cv2.putText(frame, str(len(faces_data)), (50, 50), cv2.FONT_HERSHEY_COMPLEX, 1, (50, 50, 255), 1)
        cv2.rectangle(frame, (x, y), (x + w, y + h), (50, 50, 255), 1)

    cv2.imshow("Frame", frame)
    k = cv2.waitKey(1)

    if k == ord('q') or len(faces_data) == 100:
        break

video.release()
cv2.destroyAllWindows()

# Convert to NumPy array and reshape dynamically
faces_data = np.asarray(faces_data)
faces_data = faces_data.reshape(len(faces_data), 50, 50, 3)

# Save names
if not os.path.exists(names_file):
    names = [name] * len(faces_data)
    with open(names_file, 'wb') as f:
        pickle.dump(names, f)
else:
    with open(names_file, 'rb') as f:
        names = pickle.load(f)
    names.extend([name] * len(faces_data))
    with open(names_file, 'wb') as f:
        pickle.dump(names, f)

# Save RFID data
if not os.path.exists(rfid_file):
    with open(rfid_file, 'wb') as f:
        pickle.dump(rfid_data, f)
else:
    with open(rfid_file, 'rb') as f:
        stored_rfid = pickle.load(f)
    stored_rfid.extend(rfid_data)
    with open(rfid_file, 'wb') as f:
        pickle.dump(stored_rfid, f)

# Save face data only if not duplicate
if not os.path.exists(faces_file):
    with open(faces_file, 'wb') as f:
        pickle.dump(faces_data, f)
else:
    with open(faces_file, 'rb') as f:
        stored_faces = pickle.load(f)
        stored_faces = stored_faces.reshape(-1, 50, 50, 3)

    stored_faces = np.vstack((stored_faces, faces_data))
    with open(faces_file, 'wb') as f:
        pickle.dump(stored_faces, f)

print("Face and RFID data saved successfully!")
----------------------------------------------------ADD_FACES_PY---------------------------------------
import cv2
import pickle
import numpy as np
import os
import RPi.GPIO as GPIO
import smbus2
import time
from mfrc522 import SimpleMFRC522
from skimage.metrics import structural_similarity as ssim

# Initialize RFID Reader
reader = SimpleMFRC522()

# Ensure Data Directory Exists
if not os.path.exists("data"):
    os.makedirs("data")

# File paths
faces_file = 'data/faces_data.pkl'
names_file = 'data/names.pkl'
rfid_file = 'data/rfid_data.pkl'

# Load Existing Data
if os.path.exists(faces_file):
    with open(faces_file, 'rb') as f:
        stored_faces = pickle.load(f)
        stored_faces = stored_faces.reshape(-1, 50, 50, 3)
else:
    stored_faces = np.empty((0, 50, 50, 3), dtype=np.uint8)

if os.path.exists(rfid_file):
    with open(rfid_file, 'rb') as f:
        stored_rfid = pickle.load(f)
else:
    stored_rfid = []

if os.path.exists(names_file):
    with open(names_file, 'rb') as f:
        stored_names = pickle.load(f)
else:
    stored_names = []

# Read RFID Card
print("Scan your RFID card...")
try:
    card_id, card_text = reader.read()
    print(f"RFID Card ID: {card_id}")
    name = input("Enter Your Name: ")
except Exception as e:
    print(f"RFID Error: {e}")
    exit()

# Open the camera
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

# Load Haarcascade for face detection
facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

faces_data = []
rfid_data = []
i = 0

def mse(image1, image2):
    """Mean Squared Error (MSE) between two images"""
    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)
    err /= float(image1.shape[0] * image1.shape[1])
    return err

def is_duplicate(face):
    """Check if the captured face already exists in stored_faces."""
    if stored_faces.shape[0] == 0:
        return False  

    face_gray = cv2.cvtColor(face, cv2.COLOR_BGR2GRAY)

    for stored_face in stored_faces:
        stored_face_gray = cv2.cvtColor(stored_face, cv2.COLOR_BGR2GRAY)
        
        if face_gray.shape != stored_face_gray.shape:
            continue

        mse_score = mse(face_gray, stored_face_gray)
        ssim_score = ssim(face_gray, stored_face_gray)

        if mse_score < 200 and ssim_score > 0.8:
            return True

    return False

def detect_fake_face(frame):
    """Detects if a face is being shown from a photo (Fake Face Detection)"""
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    laplacian = cv2.Laplacian(gray, cv2.CV_64F).var()
    print(f"Laplacian Value: {laplacian}")  

    if laplacian < 50:  
        print("Fake face detected! Use a real face.")
        return True
    return False

while True:
    ret, frame = video.read()
    
    if not ret:
        print("Error: Could not capture frame.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)
    duplicate_detected = False

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]

        if crop_img.size == 0:
            print("Error: Empty face image.")
            continue

        if detect_fake_face(crop_img):
            continue

        resized_img = cv2.resize(crop_img, (50, 50))

        if is_duplicate(resized_img):
            duplicate_detected = True
            cv2.putText(frame, "Duplicate Face Detected!", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 
                        0.6, (0, 0, 255), 2)
        elif len(faces_data) < 100 and i % 10 == 0:
            faces_data.append(resized_img)
            rfid_data.append(card_id)  

        i += 1
        cv2.putText(frame, str(len(faces_data)), (50, 50), cv2.FONT_HERSHEY_COMPLEX, 1, (50, 50, 255), 1)
        cv2.rectangle(frame, (x, y), (x + w, y + h), (50, 50, 255), 1)

    cv2.imshow("Frame", frame)
    k = cv2.waitKey(1)

    if k == ord('q') or len(faces_data) == 100:
        break

video.release()
cv2.destroyAllWindows()

# Convert list to NumPy array before saving
faces_data = np.array(faces_data)

# Save face data
with open(faces_file, 'wb') as f:
    pickle.dump(faces_data, f)

# Save RFID data
with open(rfid_file, 'wb') as f:
    pickle.dump(rfid_data, f)

# Save Name data
stored_names.append(name)
with open(names_file, 'wb') as f:
    pickle.dump(stored_names, f)

print("✅ Face and RFID data saved successfully!")

# Verification
with open(faces_file, 'rb') as f:
    faces_data = pickle.load(f)
    print(f"Faces Data Shape: {faces_data.shape}")

with open(names_file, 'rb') as f:
    names = pickle.load(f)
    print(f"Names Stored: {names}")

with open(rfid_file, 'rb') as f:
    rfids = pickle.load(f)
    print(f"RFID Data Stored: {rfids}")

-------------------------------------------------------TEST.py------RFID-
import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3
import RPi.GPIO as GPIO
import smbus2  # For I2C communication
import requests  # For sending attendance data to API
from mfrc522 import SimpleMFRC522  # RFID module
from sklearn.neighbors import KNeighborsClassifier

# GPIO Setup
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17  # Change according to your wiring
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)

# Initialize pyttsx3 engine for text-to-speech
engine = pyttsx3.init()

# Initialize RFID Reader
reader = SimpleMFRC522()

# LCD I2C Setup
LCD_ADDRESS = 0x27  # Check with 'sudo i2cdetect -y 1'
LCD_WIDTH = 16
LCD_CHR = 1
LCD_CMD = 0
LINE_1 = 0x80
LINE_2 = 0xC0
LCD_BACKLIGHT = 0x08
ENABLE = 0b00000100

bus = smbus2.SMBus(1)  # I2C channel 1

def lcd_byte(bits, mode):
    high_bits = mode | (bits & 0xF0) | LCD_BACKLIGHT
    low_bits = mode | ((bits << 4) & 0xF0) | LCD_BACKLIGHT
    bus.write_byte(LCD_ADDRESS, high_bits)
    lcd_toggle_enable(high_bits)
    bus.write_byte(LCD_ADDRESS, low_bits)
    lcd_toggle_enable(low_bits)

def lcd_toggle_enable(bits):
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits | ENABLE)
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits & ~ENABLE)
    time.sleep(0.0005)

def lcd_init():
    lcd_byte(0x33, LCD_CMD)
    lcd_byte(0x32, LCD_CMD)
    lcd_byte(0x06, LCD_CMD)
    lcd_byte(0x0C, LCD_CMD)
    lcd_byte(0x28, LCD_CMD)
    lcd_byte(0x01, LCD_CMD)
    time.sleep(0.005)

def lcd_display(message, line):
    lcd_byte(line, LCD_CMD)
    message = message.ljust(LCD_WIDTH, " ")
    for char in message:
        lcd_byte(ord(char), LCD_CHR)

lcd_init()  # Initialize LCD

def speak(text):
    engine.say(text)
    engine.runAndWait()

def send_attendance_api(name, date, timestamp):
    api_url = "http://localhost:5000/attendance"  # Replace with actual API
    payload = {"name": name, "date": date, "time": timestamp}
    try:
        response = requests.post(api_url, json=payload)
        if response.status_code == 200:
            print("Attendance successfully sent to API.")
        else:
            print("Failed to send attendance. Status:", response.status_code)
    except Exception as e:
        print("API Error:", e)

# Load Face Recognition Model
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Camera not found.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
    with open('data/rfid_data.pkl', 'rb') as r:
        RFID_LIST = pickle.load(r)  # Load RFID numbers
except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print("Error loading face data:", e)
    exit()

FACES = np.array(FACES).reshape(FACES.shape[0], -1)
print('Faces matrix shape:', FACES.shape)

knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

COL_NAMES = ['NAME', 'RFID', 'DATE', 'TIME']
if not os.path.exists("Attendance"):
    os.makedirs("Attendance")

attended = set()

def buzzer_and_lcd_message(name):
    for _ in range(2):
        GPIO.output(BUZZER_PIN, GPIO.HIGH)
        time.sleep(1)
        GPIO.output(BUZZER_PIN, GPIO.LOW)
        time.sleep(0.5)

    lcd_display("Attendance Taken", LINE_1)
    lcd_display(f"Name: {name}", LINE_2)
    time.sleep(3)
    lcd_display("", LINE_1)
    lcd_display("", LINE_2)

while True:
    lcd_display("Put Face in Front", LINE_1)
    lcd_display("of Camera", LINE_2)

    ret, frame = video.read()
    if not ret:
        print("Error: Frame not captured.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        if w == 0 or h == 0:
            continue

        crop_img = frame[y:y+h, x:x+w]
        if crop_img.size == 0:
            continue

        try:
            resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)
        except Exception as e:
            print("Error resizing image:", e)
            continue

        try:
            output = knn.predict(resized_img)
            recognized_name = output[0]
            print("Recognized:", recognized_name)
        except Exception as e:
            print("Prediction Error:", e)
            continue

        lcd_display("Put RFID Card", LINE_1)
        lcd_display("", LINE_2)
        speak("Put your RFID Card")

        try:
            card_id, _ = reader.read()  # Read RFID card
            print(f"RFID Card Detected: {card_id}")
        except Exception as e:
            print("RFID Error:", e)
            continue

        # Debug: Print stored RFID list and scanned RFID
        print(f"Stored RFID List: {RFID_LIST}")
        print(f"Scanned RFID: {card_id}")

        # Fix: Ensure proper matching
        if recognized_name not in attended and str(card_id).strip() in [str(rfid).strip() for rfid in RFID_LIST]:
            ts = time.time()
            date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")
            timestamp = datetime.fromtimestamp(ts).strftime("%H:%M:%S")
            attendance_file = f"Attendance/Attendance_{date}.csv"

            file_exists = os.path.isfile(attendance_file)
            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not file_exists:
                    writer.writerow(COL_NAMES)
                writer.writerow([recognized_name, card_id, date, timestamp])

            attended.add(recognized_name)
            lcd_display("Attendance Taken", LINE_1)
            lcd_display(f"Name: {recognized_name}", LINE_2)
            speak("Attendance Taken")
            send_attendance_api(recognized_name, date, timestamp)
            buzzer_and_lcd_message(recognized_name)
        else:
            lcd_display("Unauthorized Access", LINE_1)
            lcd_display("Try Again", LINE_2)
            time.sleep(2)

    cv2.imshow("Frame", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

video.release()
cv2.destroyAllWindows()
GPIO.cleanup()
---------------------------fake or real---------------------------------------------------------------
import cv2
import pickle
import numpy as np
import os
import RPi.GPIO as GPIO
import smbus2
import time
from mfrc522 import SimpleMFRC522
from skimage.metrics import structural_similarity as ssim

# Initialize RFID Reader
reader = SimpleMFRC522()

# LCD I2C Setup
LCD_ADDRESS = 0x27  # Check with 'sudo i2cdetect -y 1'
LCD_WIDTH = 16
LCD_CHR = 1
LCD_CMD = 0
LINE_1 = 0x80
LINE_2 = 0xC0
LCD_BACKLIGHT = 0x08
ENABLE = 0b00000100

bus = smbus2.SMBus(1)  # I2C channel 1

def lcd_byte(bits, mode):
    high_bits = mode | (bits & 0xF0) | LCD_BACKLIGHT
    low_bits = mode | ((bits << 4) & 0xF0) | LCD_BACKLIGHT
    bus.write_byte(LCD_ADDRESS, high_bits)
    lcd_toggle_enable(high_bits)
    bus.write_byte(LCD_ADDRESS, low_bits)
    lcd_toggle_enable(low_bits)

def lcd_toggle_enable(bits):
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits | ENABLE)
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits & ~ENABLE)
    time.sleep(0.0005)

def lcd_init():
    lcd_byte(0x33, LCD_CMD)
    lcd_byte(0x32, LCD_CMD)
    lcd_byte(0x06, LCD_CMD)
    lcd_byte(0x0C, LCD_CMD)
    lcd_byte(0x28, LCD_CMD)
    lcd_byte(0x01, LCD_CMD)
    time.sleep(0.005)

def lcd_display(message, line):
    lcd_byte(line, LCD_CMD)
    message = message.ljust(LCD_WIDTH, " ")
    for char in message:
        lcd_byte(ord(char), LCD_CHR)

# Initialize LCD
lcd_init()

# Open the camera
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Could not open camera.")
    exit()

# Load Haarcascade for face detection
facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Create data directory if not exists
if not os.path.exists('data'):
    os.makedirs('data')

faces_data = []
rfid_data = []
i = 0

# Read RFID Card
print("Scan your RFID card...")
try:
    card_id, card_text = reader.read()
    print(f"RFID Card ID: {card_id}")
    name = input("Enter Your Name: ")
except Exception as e:
    print(f"RFID Error: {e}")
    exit()

# File paths
faces_file = 'data/faces_data.pkl'
names_file = 'data/names.pkl'
rfid_file = 'data/rfid_data.pkl'

# Load existing face data if available
if os.path.exists(faces_file):
    with open(faces_file, 'rb') as f:
        stored_faces = pickle.load(f)
        stored_faces = stored_faces.reshape(-1, 50, 50, 3)
else:
    stored_faces = np.empty((0, 50, 50, 3), dtype=np.uint8)

# Load existing RFID data
if os.path.exists(rfid_file):
    with open(rfid_file, 'rb') as f:
        stored_rfid = pickle.load(f)
else:
    stored_rfid = []

def mse(image1, image2):
    """Mean Squared Error (MSE) between two images"""
    err = np.sum((image1.astype("float") - image2.astype("float")) ** 2)
    err /= float(image1.shape[0] * image1.shape[1])
    return err

def is_duplicate(face):
    """Check if the captured face already exists in stored_faces."""
    if stored_faces.shape[0] == 0:
        return False  # No stored faces yet

    face_gray = cv2.cvtColor(face, cv2.COLOR_BGR2GRAY)

    for stored_face in stored_faces:
        stored_face_gray = cv2.cvtColor(stored_face, cv2.COLOR_BGR2GRAY)
        
        if face_gray.shape != stored_face_gray.shape:
            continue

        mse_score = mse(face_gray, stored_face_gray)
        ssim_score = ssim(face_gray, stored_face_gray)

        if mse_score < 200 and ssim_score > 0.8:
            return True

    return False

def detect_fake_face(frame):
    """Detects if a face is being shown from a photo (Fake Face Detection)"""
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    laplacian = cv2.Laplacian(gray, cv2.CV_64F).var()
    print(f"Laplacian Value: {laplacian}")  # Debugging

    # Low variance indicates a fake (printed) face
    if laplacian < 50:  # Adjust this threshold based on testing
        lcd_display("This is Fake", LINE_1)
        lcd_display("Use Real Face", LINE_2)
        time.sleep(2)
        lcd_display("", LINE_1)
        lcd_display("", LINE_2)
        return True
    return False

while True:
    ret, frame = video.read()
    
    if not ret:
        print("Error: Could not capture frame.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)
    duplicate_detected = False

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]

        if crop_img.size == 0:
            print("Error: Empty face image.")
            continue

        # Detect if the face is fake
        if detect_fake_face(crop_img):
            continue

        resized_img = cv2.resize(crop_img, (50, 50))

        if is_duplicate(resized_img):
            duplicate_detected = True
            cv2.putText(frame, "Duplicate Face Detected!", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 
                        0.6, (0, 0, 255), 2)
        elif len(faces_data) < 100 and i % 10 == 0:
            faces_data.append(resized_img)
            rfid_data.append(card_id)  # Store RFID along with face data

        i += 1
        cv2.putText(frame, str(len(faces_data)), (50, 50), cv2.FONT_HERSHEY_COMPLEX, 1, (50, 50, 255), 1)
        cv2.rectangle(frame, (x, y), (x + w, y + h), (50, 50, 255), 1)

    cv2.imshow("Frame", frame)
    k = cv2.waitKey(1)

    if k == ord('q') or len(faces_data) == 100:
        break

video.release()
cv2.destroyAllWindows()
print("Face and RFID data saved successfully!")
------------------fake-face-in-test.py-------------------------------------------------------------
import cv2
import pickle
import numpy as np
import os
import csv
import time
from datetime import datetime
import pyttsx3
import RPi.GPIO as GPIO
import smbus2
import requests
from mfrc522 import SimpleMFRC522
from sklearn.neighbors import KNeighborsClassifier

# GPIO Setup
GPIO.setmode(GPIO.BCM)
BUZZER_PIN = 17
GPIO.setup(BUZZER_PIN, GPIO.OUT)
GPIO.output(BUZZER_PIN, GPIO.LOW)

# Initialize pyttsx3 engine for text-to-speech
engine = pyttsx3.init()

# Initialize RFID Reader
reader = SimpleMFRC522()

# LCD I2C Setup
LCD_ADDRESS = 0x27
LCD_WIDTH = 16
LCD_CHR = 1
LCD_CMD = 0
LINE_1 = 0x80
LINE_2 = 0xC0
LCD_BACKLIGHT = 0x08
ENABLE = 0b00000100

bus = smbus2.SMBus(1)

def lcd_byte(bits, mode):
    high_bits = mode | (bits & 0xF0) | LCD_BACKLIGHT
    low_bits = mode | ((bits << 4) & 0xF0) | LCD_BACKLIGHT
    bus.write_byte(LCD_ADDRESS, high_bits)
    lcd_toggle_enable(high_bits)
    bus.write_byte(LCD_ADDRESS, low_bits)
    lcd_toggle_enable(low_bits)

def lcd_toggle_enable(bits):
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits | ENABLE)
    time.sleep(0.0005)
    bus.write_byte(LCD_ADDRESS, bits & ~ENABLE)
    time.sleep(0.0005)

def lcd_init():
    lcd_byte(0x33, LCD_CMD)
    lcd_byte(0x32, LCD_CMD)
    lcd_byte(0x06, LCD_CMD)
    lcd_byte(0x0C, LCD_CMD)
    lcd_byte(0x28, LCD_CMD)
    lcd_byte(0x01, LCD_CMD)
    time.sleep(0.005)

def lcd_display(message, line):
    lcd_byte(line, LCD_CMD)
    message = message.ljust(LCD_WIDTH, " ")
    for char in message:
        lcd_byte(ord(char), LCD_CHR)

lcd_init()

def speak(text):
    engine.say(text)
    engine.runAndWait()

def send_attendance_api(name, date, timestamp):
    api_url = "http://localhost:5000/attendance"
    payload = {"name": name, "date": date, "time": timestamp}
    try:
        response = requests.post(api_url, json=payload)
        if response.status_code == 200:
            print("Attendance successfully sent to API.")
        else:
            print("Failed to send attendance. Status:", response.status_code)
    except Exception as e:
        print("API Error:", e)

# Load Face Recognition Model
video = cv2.VideoCapture(0)
if not video.isOpened():
    print("Error: Camera not found.")
    exit()

facedetect = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

try:
    with open('data/names.pkl', 'rb') as w:
        LABELS = pickle.load(w)
    with open('data/faces_data.pkl', 'rb') as f:
        FACES = pickle.load(f)
    with open('data/rfid_data.pkl', 'rb') as r:
        RFID_LIST = pickle.load(r)
except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    print("Error loading face data:", e)
    exit()

FACES = np.array(FACES).reshape(FACES.shape[0], -1)
print('Faces matrix shape:', FACES.shape)

knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(FACES, LABELS)

COL_NAMES = ['NAME', 'RFID', 'DATE', 'TIME']
if not os.path.exists("Attendance"):
    os.makedirs("Attendance")

attended = set()

def buzzer_and_lcd_message(name):
    for _ in range(2):
        GPIO.output(BUZZER_PIN, GPIO.HIGH)
        time.sleep(1)
        GPIO.output(BUZZER_PIN, GPIO.LOW)
        time.sleep(0.5)

    lcd_display("Attendance Taken", LINE_1)
    lcd_display(f"Name: {name}", LINE_2)
    time.sleep(3)
    lcd_display("", LINE_1)
    lcd_display("", LINE_2)

def detect_fake_face(frame):
    """Detects if a face is from a photo (Fake Face Detection)"""
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    laplacian = cv2.Laplacian(gray, cv2.CV_64F).var()
    print(f"Laplacian Value: {laplacian}")  

    if laplacian < 50:  
        lcd_display("This is Fake", LINE_1)
        lcd_display("Use Real Face", LINE_2)
        GPIO.output(BUZZER_PIN, GPIO.HIGH)
        time.sleep(1)
        GPIO.output(BUZZER_PIN, GPIO.LOW)
        time.sleep(2)
        lcd_display("", LINE_1)
        lcd_display("", LINE_2)
        return True
    return False

while True:
    lcd_display("Put Face in Front", LINE_1)
    lcd_display("of Camera", LINE_2)

    ret, frame = video.read()
    if not ret:
        print("Error: Frame not captured.")
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = facedetect.detectMultiScale(gray, 1.3, 5)

    for (x, y, w, h) in faces:
        crop_img = frame[y:y+h, x:x+w]

        if detect_fake_face(crop_img):  
            continue  

        try:
            resized_img = cv2.resize(crop_img, (50, 50)).flatten().reshape(1, -1)
        except Exception as e:
            print("Error resizing image:", e)
            continue

        try:
            output = knn.predict(resized_img)
            recognized_name = output[0]
            print("Recognized:", recognized_name)
        except Exception as e:
            print("Prediction Error:", e)
            continue

        lcd_display("Put RFID Card", LINE_1)
        lcd_display("", LINE_2)
        speak("Put your RFID Card")

        try:
            card_id, _ = reader.read()
            print(f"RFID Card Detected: {card_id}")
        except Exception as e:
            print("RFID Error:", e)
            continue

        if recognized_name not in attended and str(card_id).strip() in [str(rfid).strip() for rfid in RFID_LIST]:
            ts = time.time()
            date = datetime.fromtimestamp(ts).strftime("%d-%m-%Y")
            timestamp = datetime.fromtimestamp(ts).strftime("%H:%M:%S")
            attendance_file = f"Attendance/Attendance_{date}.csv"

            with open(attendance_file, "a", newline='') as csvfile:
                writer = csv.writer(csvfile)
                if not os.path.isfile(attendance_file):
                    writer.writerow(COL_NAMES)
                writer.writerow([recognized_name, card_id, date, timestamp])

            attended.add(recognized_name)
            lcd_display("Attendance Taken", LINE_1)
            lcd_display(f"Name: {recognized_name}", LINE_2)
            speak("Attendance Taken")
            send_attendance_api(recognized_name, date, timestamp)
            buzzer_and_lcd_message(recognized_name)

    cv2.imshow("Frame", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

video.release()
cv2.destroyAllWindows()
GPIO.cleanup()
